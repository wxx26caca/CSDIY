# RabbitMQ

## 简介

- 用 Erlang 实现的基于 AMQP 的消息中间件
- 特点：
    - 可靠性：持久化、传输确认以及发布确认等方式
    - 灵活的路由：消息在进入队列之前，通过交换器来路由消息
    - 扩展性：集群
    - 高可用性：队列可以在集群中的机器上设置镜像，使得部分节点出现问题的时候队列仍然可用
    - 支持多种协议：eg：STOMP、MQTT 等多种消息中间件协议
    - 多语言客户端：
    - 管理界面简单，易用：
    - 插件机制
- 使用场景
    - 服务间异步通信
    - 顺序消费
    - 定时任务
    - 请求削峰

## 核心概念

![RabbitMQ 整体模型](https://camo.githubusercontent.com/f69f73da9ea6a570fbd5f7c6c48c87e317e78dab485e8999076e19317470405d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f39363338383534362e6a7067)

- Producer
- Consumer

消息一般由 2 部分组成，消息头和消息体，消息体也可以称为 payload，消息体不透明。消息头则由一系列的可选属性组成，包括 routing-key（路由键），priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）

- Exchange

    routing-key 需要与交换器类型和绑定键 binding-key 联合使用才能生效。可以把交换器理解成一个由绑定构成的路由表。

    - direct

        会把消息路由到 bindingKey 与 routingKey 完全匹配的 Queue

        常用来处理由优先级的任务，根据优先级把消息发送到对应的队列

    - fanout

        常用来广播消息

    - topic

        类似正则匹配

        - RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;
        - BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；
        - BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。

    - headers

        headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)'对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。

- Queue

    RabbitMQ 中消息只能存储在队列中，和 Kafka 不同。消息会一直在队列里面，等待消费者连接到这个队列将其取走。

    多个消费者可以订阅同一个队列，这时候队列中的消息会被平均分摊（Round-Robin）给多个消费者进行处理

    RabbitMQ 不支持队列层面的广播消费，不建议这样做

- Broker

    一个 Broker 可以简单看作一个 RabbitMQ 服务器

    ![存储以及消费数据流程](https://camo.githubusercontent.com/04a3dfc174e53a9503bc414f81e17f0c8839725304a43a23a3c715d7f9d62e09/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d31362f36373935323932322e6a7067)

- vhost

    vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。

## 简单操作

- 浏览器访问：http://ip_address:15672/

- 新建用户并授权：

    ```shell
    rabbitmqctl add_user root root
    rabbitmqctl set_user_tags root administrator
    rabbitmqctl set_permissions -p / root ".*" ".*" ".*"
    rabbitmqctl list_users
    ```

## MQ 优点

- 应用解耦 - 一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用关系很复杂，维护起来麻烦
- 异步处理 - 
- 流量削峰 - 减少高峰时期对服务器的压力
- 日志处理 - 解决大量日志传输的问题
- 消息通讯

## MQ 缺点

- 系统可用性降低 - 如果消息队列挂了，系统 GG 了
- 系统复杂度提高 - 一致性问题，保证消息不被重复消费、消息的可靠性传输

## 生产环境是如何使用 RabbitMQ 的

openstack rabbitmq

## MQ 消息的顺序问题和重复问题

- 顺序问题
    - 保证生产这 - MQServer - 消费者是一一对应关系
    - 可能的缺陷：并行度不够；只要有一端出现问题，就会导致整个处理流程阻塞
- 重复问题
    - 保证网络的通畅，消费端处理消息的业务逻辑保持幂等性

## 如何确保消息正确地发送到 RabbitMQ？如何保证消息接收方消费了消息？

- 发送方确认模式

    将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。

    一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。

    如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。

    发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。

- 接收方确认机制

    消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。

    RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；

    - 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）
    - 如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。

## 生产者消息运转

1. Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)。

2. Producer声明一个交换器并设置好相关属性。

3. Producer声明一个队列并设置好相关属性。

4. Producer通过路由键将交换器和队列绑定起来。

5. Producer发送消息到Broker,其中包含路由键、交换器等信息。

6. 相应的交换器根据接收到的路由键查找匹配的队列。

7. 如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。

8. 关闭信道。

9. 关闭连接。

## 消费者接收消息过程

1. Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)。

2. 向Broker请求消费响应的队列中消息，可能会设置响应的回调函数。

3. 等待Broker回应并投递相应队列中的消息，接收消息。

4. 消费者确认收到的消息 ack。

5. RabbitMq从队列中删除已经确定的消息。

6. 关闭信道。

7. 关闭连接。

## RabbitMQ中消息可能有的几种状态?

alpha: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中 。

beta: 消息内容保存在磁盘中，消息索引保存在内存中。

gamma: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。

delta: 消息内容和索引都在磁盘中 。

## 参考文章

https://juejin.cn/post/6844904192146931720